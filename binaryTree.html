<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二叉树</title>
</head>
<body>
    <script>
        //二叉树的遍历
        /*
            按照顺序规则的不同，遍历方式有以下四种：
            1.先序遍历
            2.后序遍历
            3.中序遍历
            4.层次遍历

            按照实现方式的不同，遍历方式又可以分为以下两种：
            1.递归遍历(先、中、后序遍历)
            2.迭代遍历(层次遍历)
        */

        //二叉树构造函数
        function TreeNode(val){
            this.val = val;
            this.left = this.right = null;
        }

        const node = new TreeNode("A");
        const nodeB = node.left = new TreeNode("B");
        const nodeC = node.right = new TreeNode("C");
        nodeB.left = new TreeNode("D");
        nodeB.right = new TreeNode("E");
        nodeC.right = new TreeNode("F");
        console.log(node);
        /* 形成数据结构为
            {
                val: "A",
                left: {
                    val: "B",
                    left: {
                        val: "D",
                        left: null,
                        right: null
                    }
                    right: {
                        val: "E",
                        left: null,
                        right: null
                    }
                },
                right: {
                    val: "C",
                    right: {
                        val: "F",
                        left: null,
                        right: null 
                    },
                    left: null
                }
            }
         */
        
         //递归函数的编写要点
         /*
           1.递归式，它指的是你每一次重复的内容是什么。在这里，我们要做先序遍历，那么每一次重复的其实就是 根结点 -> 左子树 -> 右子树 这个旅行路线。
           2.递归边界，它指的是你什么时候停下来。 
         */
         console.log("先序遍历");
         //先序遍历编码实现
         function preorder(node){
            if(!node){
                return;
            }
            // 输出当前遍历的结点值
            console.log("当前遍历的结点值是:" + node.val);
            //遍历左子树
            preorder(node.left);
            //遍历右子树
            preorder(node.right);
         }
         preorder(node);

         console.log("中序遍历");
         //中序遍历编码实现
         function inorder(root){
             if(!root){
                 return;
             }
             //先遍历左子树
             inorder(root.left);
             // 输出当前遍历的结点值
             console.log('当前遍历的结点值是:', root.val);
             //再遍历右子树
             inorder(root.right);
         }
         inorder(node);

         console.log("后序遍历");
         //后序遍历
         function postorder(root){
             if(!root){
                 return;
             }
             //先遍历左子树
             postorder(root.left);
             //再遍历右子树
             postorder(root.right);
             //输出当前值
            console.log('当前遍历的结点值是:', root.val);
         }
         postorder(node);
    </script>
</body>
</html>